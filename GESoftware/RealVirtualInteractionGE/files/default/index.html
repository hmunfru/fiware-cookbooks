<!doctype html>
<html lang="us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="Cyberlightning FI-WARE - IoT project, Author: Tomi Sarni">
    <meta name="viewport" content="width=device-width">
    <title>Cyberlightning FI-WARE</title>

    <link href="css/eggplant/jquery-ui-1.10.3.custom.css" rel="stylesheet">

	<script src="js/jquery-1.9.1.js"></script>
	<script src="js/jquery-ui-1.10.3.custom.js"></script>
	<script src="js/three.min.js"></script>
<!-- 	<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script> -->
	
    <script type="text/javascript">
	 $(function() {
		 $( "#accordion" ).accordion();
		 });
	</script>
	
	<style>
	body{
		font: 62.5% "Trebuchet MS", sans-serif;
		margin: 30px;
		background-color:#1F001F;
	} #buttons div {
  		display: inline;
  		width:100%;
  	}.btn {
    display: inline-block;
    margin-right: 6px;
    }#content_left {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyYWRpYWxHcmFkaWVudCBpZD0iZyI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmFiYWI5Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmZmZmIi8+PC9yYWRpYWxHcmFkaWVudD48cmVjdCB4PSIwJSIgeT0iMCUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNmZmZmZmYiIC8+PHJlY3QgeD0iLTMzLjYzNzIlIiB5PSItMTYxLjUxNDIlIiB3aWR0aD0iMjY3LjI3NDQlIiBoZWlnaHQ9IjUyMy4wMjgzJSIgZmlsbD0idXJsKCNnKSIgLz48L3N2Zz4=);
    background-image: -webkit-gradient(radial, 100% 100%, 0, 100% 100%, 303, color-stop(0%, #babab9), color-stop(100%, #ffffff));
    background-image: -webkit-radial-gradient(right bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -moz-radial-gradient(right bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -ms-radial-gradient(right bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -o-radial-gradient(right bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: radial-gradient(farthest-corner circle at right bottom, #babab9 0%, #ffffff 118.9999%);
    }#content_right {
    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyYWRpYWxHcmFkaWVudCBpZD0iZyI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjYmFiYWI5Ii8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmZmZmIi8+PC9yYWRpYWxHcmFkaWVudD48cmVjdCB4PSIwJSIgeT0iMCUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNmZmZmZmYiIC8+PHJlY3QgeD0iLTEzMy42MzcyJSIgeT0iLTE2MS41MTQyJSIgd2lkdGg9IjI2Ny4yNzQ0JSIgaGVpZ2h0PSI1MjMuMDI4MyUiIGZpbGw9InVybCgjZykiIC8+PC9zdmc+);
    background-image: -webkit-gradient(radial, 0% 100%, 0, 0% 100%, 303, color-stop(0%, #babab9), color-stop(100%, #ffffff));
    background-image: -webkit-radial-gradient(left bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -moz-radial-gradient(left bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -ms-radial-gradient(left bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: -o-radial-gradient(left bottom, farthest-corner circle, #babab9 0%, #ffffff 118.9999%);
    background-image: radial-gradient(farthest-corner circle at left bottom, #babab9 0%, #ffffff 118.9999%);
    }
    </style>
</head>

<body>
		<div align="left" style="width:100%;height:100px">
			<img alt="" src="favicon.ico" style="height:32px">	
		</div>
	    <div align="right" style="width:100%">
            <button id="connect_button" style="display: inline-block;" onClick="WebSocketTest()">connect</button>
            <form style="display: inline-block;" id="frm"><input id="command_input" type="text" placeholder="Command to be sent to sensor"></form>
			<button style="display: inline-block;" id="send_button" onClick="sendData()">Send</button></div>
		<div style="width:100%;height:100%">

  			<div id="content_left" style="background-color:#D2CCD2;height:650px;width:49%;float:left;"></div>
  			<div style="background-color:#938F93;height:650px;width:0.3%;float:left;"></div>
  			<div id="content_right" style="background-color:#D2CCD2;height:650px;width:50.7%;float:left;">
				<div id="accordion"></div>
  			</div>
  			<div align="right" style="background-color:#4C334C;clear:both;color:white;font-size: 9">Copyright Â© 2013 Cyberlightning Ltd.</div>
 			<div id="device_control" style="width:100%;"></div>
  		</div>
		<div id="holder">
		</div> <!-- This needs to be removed, dummy layer for JSON data -->
	
	<script type="text/javascript">
	
	//Global variables
	
	var WIDTH = $("#content_left").height() + 100;
	var HEIGHT = $("#content_left").width();
	

	// set some camera attributes
	var VIEW_ANGLE = 45,
	  ASPECT = WIDTH / HEIGHT,
	  NEAR = 0.1,
	  FAR = 10000;

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#content_left');

	// create a WebGL renderer, camera
	// and a scene
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	
	var ws; //websocket 
	var json;
    var type;
    var map;
	var lat;
	var lon;
    var entities = {};
    var selectedUUID = null;
    var gpsShown = false;
    var selectedSensor;
    var listOfUUIDS;
    var valueContainer = {};

    function createButton(currentUuid) {
        $("#device_control").append('<button style="display: inline-block;" onClick="changeDevice(event)">'+currentUuid+'</button>')
    }
    function changeDevice(e) {
        this.selectedUUID = e.currentTarget.innerHTML;
        updateContent(entities[selectedUUID]);
         drawCharts(uuid);
    }
	function setContent() {

		var currentUUID;
        for (var baseUUID in json) {
		    if (json.hasOwnProperty(baseUUID)) {
		    	for (var deviceUUID in json[baseUUID]){
		    		var device = json[baseUUID];
		    		entities[deviceUUID] = device[deviceUUID];
                    currentUUID = deviceUUID;

                    if(listOfUUIDS == null) {
                        listOfUUIDS = [];
                        listOfUUIDS[0] = deviceUUID;
                        //currentUuid = deviceUUID;
                        createButton(deviceUUID);
                    } else {
                        var contains = false;
                        for(var k=0; k< listOfUUIDS.length; k++) {
                            if(listOfUUIDS[k] == deviceUUID) {
                             contains = true;
                            }
                        }
                        if(!contains){
                            listOfUUIDS.push(deviceUUID);
                            //currentUuid = deviceUUID;
                             createButton(deviceUUID);
                        }
                    }

		    	}
		        
		    }
		}
        if (selectedUUID) {
            if (selectedUUID == currentUUID) {
            updateValueHistory(entities[currentUUID],currentUUID);
            updateContent(valueContainer[currentUUID]);
            drawCharts(currentUUID);
            }else {
               updateValueHistory(entities[currentUUID],currentUUID);
            }
        }else {
            selectedUUID = currentUUID;
            updateValueHistory(entities[currentUUID],currentUUID);
            updateContent(valueContainer[currentUUID]);
            drawCharts(currentUUID);
        }


	}

    function updateValueHistory(obj,uuid){
        var hasEntries = false;

        if (valueContainer.hasOwnProperty(uuid)) {
            hasEntries = true;
            var existingValues = valueContainer[uuid];

            for (var j  = 0; j < obj.sensors.length; j++) {
                if(existingValues.hasOwnProperty(obj.sensors[j].attributes.type)){
                    if(existingValues[obj.sensors[j].attributes.type].value.values.length > 4) {
                            var tempArray = [];
                            var dd = existingValues[obj.sensors[j].attributes.type].value.values;
                            for (var k = 1; k < dd.length; k++) {
                                tempArray.push(dd[k]);
                            }
                            tempArray.push(obj.sensors[j].value.values);
                            existingValues[obj.sensors[j].attributes.type].value.values = tempArray;
                    }else {
                            var tempArray = [];
                            var dd = existingValues[obj.sensors[j].attributes.type].value.values;
                            for (var k = 0; k < dd.length; k++) {
                                tempArray.push(dd[k]);
                            }
                            tempArray.push(obj.sensors[j].value.values);
                            existingValues[obj.sensors[j].attributes.type].value.values = tempArray;
                        }
                } else {
                    var valuesArray = [];
                    valuesArray.push(obj.sensors[j].value.values);
                    var sensor = obj.sensors[j];
                    sensor.value.values = valuesArray;
                    existingValues[obj.sensors[j].attributes.type] = sensor;
                }

            }
        valueContainer[uuid] = existingValues;
        }



        if (!hasEntries ) {
            var sensorvals = {};
            for (var j = 0; j < obj.sensors.length; j++) {
               var valuesArray = [];
               valuesArray.push(obj.sensors[j].value.values);
               var sensor = obj.sensors[j];
               sensor.value.values = valuesArray;
               sensorvals[obj.sensors[j].attributes.type] = sensor;
            }
            valueContainer[uuid] = sensorvals;

        }

    }

    function updateContent(obj) {
        var accordion = document.getElementById('accordion');
        while(accordion.hasChildNodes()) {
            accordion.removeChild(accordion.lastChild);
        }

        addNewContent(obj);
    }


    function addNewContent(obj) {
        var sensors = valueContainer[selectedUUID];
        var attr = [];
        for (var sensor in sensors) {
            if(sensors.hasOwnProperty(sensor)) {
             type = sensor;
             var active = $('#accordion').accordion('option', 'active');
             $('#accordion').append('<h3><a href="#" onclick="drawCharts(event)">' + type + '</a></h3><div>'+ parseContent(sensors[sensor], null) +'</div>').accordion('destroy').accordion({ active: active});

            if (entities[selectedUUID].attributes.gps != null && gpsShown == false) {
               gpsShown = true;
            	lat = parseFloat(entities[selectedUUID].attributes.gps[0]);
				lon = parseFloat(entities[selectedUUID].attributes.gps[1]);
				$('#accordion').accordion({heightStyle: 'content'});
				$('#accordion').append('<h3><a href="#" onclick="loadMap(event)">gps</a></h3><div>'+ parseContent(sensors[sensor],entities[selectedUUID].attributes.gps) +'</div>').accordion('destroy').accordion({ active: active});
            }
            }

        }
        gpsShown = false;
    }

    function loadMap(e) {
        //TODO
    }

    function parseContent(obj,loc) {
        var content = "<b>Device Id: </b><i>" + selectedUUID + "</i>   <b>Latest Event: </b><i>" + (new Date()).toString() + "</i></br>";
        if(loc != null){
            content += "<b>Location: </b>[" +loc + "] ";
        }else {
            content += "<b>Sensor value: </b>";
             if (obj.value.primitive != "double") {
                 //var sensors = valueContainer[selectedUUID]
                 //var values = sensors[obj.attributes.type];
                 var values = obj.value.values;
                 content += "</br>"
                 var linenumber = 1;
                 for (var l = (values.length - 1); l > -1; l--) {
                     var valueArray = values[l];
                     content += "<b>"+linenumber+ ". </b>"+"[ ";
                     linenumber++;
                     for (var d = 0; d < valueArray.length; d++) {
                        if (d < 2) content +=valueArray[d] + ", ";
                        else content += valueArray[d];
                     }
                     content += " ] (<i>" + obj.value.unit + "</i>)</br> ";

                 }
             } else {
                 //var sensors = valueContainer[selectedUUID]
                 var values = obj.value.values;
                 content += "</br>"
                 var linenumber = 1;
                 for (var l = (values.length -1); l > -1; l--) {
                     content += "<b>" + linenumber + ".</b> "+ values[l] + " " + obj.value.unit + "</br>";
                     linenumber++;
                 }

             }
        }
        return content;
    }


	function drawCharts(e) {

        var eventTarget;
		if (selectedSensor == null ) {
            if (e.currentTarget == null) {
                return;
            } else {
                selectedSensor = e.currentTarget.innerHTML;
            }

        }
        if (e.currentTarget != null) {
            if(selectedSensor != e.currentTarget.innerHTML){
            selectedSensor = e.currentTarget.innerHTML;
            }
        }

        eventTarget = selectedSensor;
		var cubeX = 20;
		var cubeZ = 20;
		var cubeY = 0;
		
		var tempSensorList = entities[selectedUUID].sensors;
		
		

        var valueList = [];
		var minValue;
		var maxValue;
        var is3DPoint = false;
        var threeDPointValues = [];

        var camera = new THREE.PerspectiveCamera(
				    VIEW_ANGLE,
				    ASPECT,
				    NEAR,
				    FAR);

		var scene = new THREE.Scene();

		scene.add(camera);

			// the camera starts at 0,0,0
			// so pull it back
			camera.position.z = 300;
			camera.position.y = 200;
			camera.position.x = 100;

			// start the renderer
			renderer.setSize(WIDTH, HEIGHT);

			// attach the render-supplied DOM element
			$container.append(renderer.domElement);

			// create a point light

        var temperatureArray = [];
        var device = valueContainer[selectedUUID];
        for (var sensor in device){
            if(sensor == eventTarget ){
                var tempArray = device[sensor].value.values;
                if( device[sensor].value.primitive == "3DPoint" || device[sensor].value.primitive == "array"  ) {
                    is3DPoint = true;
                	for (var k=0; k < tempArray.length; k++) {
                		threeDPointValues.push(tempArray[k]);
                	}
                } else {
                    temperatureArray = device[sensor].value.values;
                	for (var c = 0; c < tempArray.length; c++) {
                        if (minValue > parseFloat(tempArray[c]) || minValue == null) {
					    	minValue = parseFloat(tempArray[c]);
				        } if (maxValue < parseFloat(tempArray[c]) || maxValue == null) {
					        maxValue = parseFloat(tempArray[c]);
			            }
                    }
                }
            }
        }

		if (is3DPoint){
            var points = threeDPointValues[0];
       		var material = new THREE.LineBasicMaterial({color: 0x0000ff,linewidth: 3, fog:true});

		    var geometry = new THREE.Geometry();
		    geometry.vertices.push(new THREE.Vector3(0, 50, 0));
		    geometry.vertices.push(new THREE.Vector3(0, (10*points[1]) + 50, 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

            material = new THREE.LineBasicMaterial({color: 0x00ff00,linewidth: 3, fog:true});
            geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(0, 50, 0));
			geometry.vertices.push(new THREE.Vector3(0, 50, (points[2]*10) ));

			line = new THREE.Line(geometry, material);
		    scene.add(line);

			material = new THREE.LineBasicMaterial({color: 0xff0000,linewidth: 3, fog:true});
			geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 50, 0));
			geometry.vertices.push(new THREE.Vector3((points[0]*10),50, 0));

			line = new THREE.Line(geometry, material);
			scene.add(line);
			camera.lookAt( scene.position );
            renderer.render(scene, camera);

        } else {
            var material = new THREE.LineBasicMaterial({color: 0x111111});

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 110, 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(0, 0, 90));

			var line = new THREE.Line(geometry, material);
			scene.add(line);

			var geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0, 0, 0));
			geometry.vertices.push(new THREE.Vector3(110,0 , 0));

			var line = new THREE.Line(geometry, material);
			scene.add(line);
			camera.lookAt( scene.position );

			var j = 0;

			while(j < temperatureArray.length && j < 5) {

				    if(minValue == maxValue) {
                         cubeY = 50;
                    } else {
                        cubeY = (parseFloat(temperatureArray[j])/ maxValue) * 100;
                    }

				    var geometry = new THREE.CubeGeometry( cubeX, cubeY, cubeZ );

        		    for ( var i = 0; i < geometry.faces.length; i += 2 ) {
					    var hex = (i*15-j*10)+ 0x633664;
        			    geometry.faces[ i ].color.setHex( hex );
        			    geometry.faces[ i + 1 ].color.setHex( hex );
        		    }

        		    var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
        		    cube = new THREE.Mesh( geometry, material );
        		    cube.position.y = cubeY/2;
        		    cube.position.x = cubeX/2 + j*20; //20 pixels space between bars after first
        		    cube.position.z = cubeZ/2;
        		    scene.add( cube );

        		    j++
			    }
            var canvas1 = document.createElement('canvas');
    		var context1 = canvas1.getContext('2d');
    		context1.font = "14px Arial";
    		context1.fillStyle = "rgba(0,0,0,0.95)";
    		context1.fillText("Value range: " + parseFloat(minValue).toFixed(2) + " - " + parseFloat(maxValue).toFixed(2), 0, 50);

    		// canvas contents will be used for a texture
    		var texture1 = new THREE.Texture(canvas1)
    		texture1.needsUpdate = true;

    		    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    		    material1.transparent = true;

    		    var mesh1 = new THREE.Mesh(
    		        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
    		        material1
    		      );
    		mesh1.position.set(40,20,-300);
            scene.add( mesh1 );
            var pointLight = new THREE.PointLight(0xFFFFFF);

			// set its position
			pointLight.position.x = 10;
			pointLight.position.y = 50;
			pointLight.position.z = 130;

			// add to the scene
			scene.add(pointLight);
            renderer.render(scene, camera);
            }



	}

    function sendData() {
		var input = "device_id=" +selectedUUID+"&message=" + frm.command_input.value;
        ws.send(input);
	};


	function WebSocketTest() {
       
		if ("WebSocket" in window) {
          // Check if connection is already open before creating new so we do not spam server with duplicate connections.
          if (ws != null && ws.readyState === ws.OPEN)
          {
          	alert("Websocket connection is already established!");
          	return;
          }
          else
          	{
				// Use localhost IP for websocket
                var clientIP = location.hostname;
				ws = new WebSocket("ws://"+clientIP+":44445");

				
          	}
          ws.onopen = function() {
             // Web Socket is connected, send data using send()
            //ws.send("Message to send");
             alert("Connected to the web server."); 	 
          };
          ws.onmessage = function (evt) {
        	document.getElementById("holder").innerHTML = evt.data;
            json = JSON.parse(document.getElementById("holder").innerHTML);
            document.getElementById("holder").innerHTML = "";
            setContent();
          };
          ws.onclose = function() {
             // websocket is closed.
             ws = null;
             alert("Connection is closed...");
          };
       }
       else {
          // The browser doesn't support WebSocket
          alert("WebSocket NOT supported by your Browser!");
       }
     }	
	 
	</script>
</body>
</html>
